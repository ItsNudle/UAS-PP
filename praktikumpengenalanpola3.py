# -*- coding: utf-8 -*-
"""PraktikumPengenalanPola3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19BQfRfYlE6UDinkowd69K0KLKtfTwdpQ
"""

pip install ucimlrepo

from ucimlrepo import fetch_ucirepo

zoo = fetch_ucirepo(id=111)

x = zoo.data.features
y = zoo.data.targets

x

y

zoo.metadata

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

columns = [
    'animal_name', 'hair', 'feathers', 'eggs', 'milk',
    'airborne', 'aquatic','predator','toothed',
    'backbone','breathes','venomous','fins',
    'legs','tail','domestic','catsize','type']

df = pd.read_csv('zoo.data',header=None,names=columns)

print(df.head())

x = df.drop(['type','animal_name'],axis=1)
x.head()

y = df['type']

x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=20,random_state = 5)

zoo_model = GaussianNB()

NB_train = zoo_model.fit(x_train,y_train)

y_pred = NB_train.predict(x_test)
np.array(y_pred)

import itertools
from sklearn.metrics import confusion_matrix

def plot_confusion_matrix(cm, title='Confusion matrix', cmap=plt.cm.Blues):
  plt.imshow(cm, interpolation='nearest', cmap=cmap)
  plt.title(title)
  plt.colorbar()
  tick_marks = np.arange(len(list(range(1,8))))
  plt.xticks(tick_marks, rotation=45)
  ax = plt.gca()
  ax.set_xticklabels((ax.get_xticks() +1).astype(str))
  plt.yticks(tick_marks)
  ax.set_yticklabels((ax.get_yticks() +1).astype(str))

  thresh = cm.max() / 2.
  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, format(cm[i, j], '.1f'),
    horizontalalignment="center",
    color="white" if cm[i, j] > thresh else "black")

cm = confusion_matrix(y_test, y_pred)
np.set_printoptions(precision=1) #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
print('Confusion matrix, without normalization')
print(cm)
fig, ax = plt.subplots()
plot_confusion_matrix(cm)

plt.show()

print(classification_report(y_test,y_pred))

pip install kneed

import matplotlib.pyplot as plt
from kneed import KneeLocator
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import StandardScaler

features, true_labels = make_blobs(n_samples=200, centers=3, cluster_std=2.75, random_state=42)
features.shape

features[:5]

true_labels[:5]

scaler = StandardScaler()
scaled_features = scaler.fit_transform(features)

scaled_features[:5]

k_means = KMeans(init='random', n_clusters=3, n_init=10, max_iter=300, random_state=42)
k_means.fit(scaled_features)

k_means.inertia_

k_means.cluster_centers_

k_means.n_iter_

import matplotlib.pyplot as plt

predicted_labels = k_means.labels_

plt.figure(figsize=(8,6))
plt.scatter(scaled_features[:,0], scaled_features[:,1], c=predicted_labels, cmap='viridis',marker='o',edgecolors='k',s=50)
plt.scatter(k_means.cluster_centers_[:,0], k_means.cluster_centers_[:,1], c='red', marker='X', s=200, label='Centroids')
plt.xlabel('Feature 1 (scaled)')
plt.ylabel('Feature 2 (scaled)')
plt.title('K-Means Clustering')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import sklearn

!wget -O FuelConsumption.csv https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/ML0101ENv3/labs/FuelConsumptionCo2.csv

df = pd.read_csv("FuelConsumption.csv")
df.head()

df.describe()

cdf = df[['ENGINESIZE','CYLINDERS','FUELCONSUMPTION_COMB','CO2EMISSIONS']]
cdf.head(10)

viz = cdf[['CYLINDERS','ENGINESIZE','CO2EMISSIONS','FUELCONSUMPTION_COMB']]
viz.hist()
plt.show()

plt.scatter(cdf.FUELCONSUMPTION_COMB, cdf.CO2EMISSIONS,  color='blue')
plt.xlabel("FUELCONSUMPTION_COMB")
plt.ylabel("Emission")
plt.show()

plt.scatter(cdf.ENGINESIZE, cdf.CO2EMISSIONS,  color='blue')
plt.xlabel("Engine size")
plt.ylabel("Emission")

plt.scatter(cdf.CYLINDERS, cdf.CO2EMISSIONS, color='blue')
plt.xlabel("Cylinders")
plt.ylabel("Emission")

X = cdf.iloc[:, 0].values
y = cdf.iloc[:, 3].values
X = X.reshape(-1, 1)
y = y.reshape(-1, 1)
y

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

y
from sklearn.preprocessing import StandardScaler
sc_X = StandardScaler()
sc_y = StandardScaler()
X = sc_X.fit_transform(X)
y = sc_y.fit_transform(y)
y

from sklearn.tree import DecisionTreeRegressor
regressor = DecisionTreeRegressor()
regressor.fit(X, y)

y_pred = regressor.predict(sc_X.transform(np.array([[5.4]])))

# Reshape y_pred to a 2D array before inverse transforming
y_pred = y_pred.reshape(-1, 1)
y_pred = sc_y.inverse_transform(y_pred)
print(y_pred)

X_grid = np.arange(min(X), max(X), 0.01)
X_grid = X_grid.reshape((len(X_grid), 1))
plt.scatter(X, y, color = 'red')
plt.plot(X_grid, regressor.predict(X_grid), color = 'blue')
plt.title('Truth or Bluff (Decision Tree Regression)')

